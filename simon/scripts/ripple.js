'use strict'; /**
               * @license
               * Copyright 2015 Google Inc. All Rights Reserved.
               *
               * Licensed under the Apache License, Version 2.0 (the "License");
               * you may not use this file except in compliance with the License.
               * You may obtain a copy of the License at
               *
               *      http://www.apache.org/licenses/LICENSE-2.0
               *
               * Unless required by applicable law or agreed to in writing, software
               * distributed under the License is distributed on an "AS IS" BASIS,
               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
               * See the License for the specific language governing permissions and
               * limitations under the License.
               */

(function () {
  'use strict';

  /**
                 * Class constructor for Ripple MDL component.
                 * Implements MDL component design pattern defined at:
                 * https://github.com/jasonmayes/mdl-component-design-pattern
                 *
                 * @constructor
                 * @param {HTMLElement} element The element that will be upgraded.
                 */
  var MaterialRipple = function MaterialRipple(element) {
    this.element_ = element;

    // Initialize instance.
    this.init();
  };
  window['MaterialRipple'] = MaterialRipple;

  /**
                                              * Store constants in one place so they can be updated easily.
                                              *
                                              * @enum {string | number}
                                              * @private
                                              */
  MaterialRipple.prototype.Constant_ = {
    INITIAL_SCALE: 'scale(0.0001, 0.0001)',
    INITIAL_SIZE: '1px',
    INITIAL_OPACITY: '0.4',
    FINAL_OPACITY: '0',
    FINAL_SCALE: '' };


  /**
                        * Store strings for class names defined by this component that are used in
                        * JavaScript. This allows us to simply change it in one place should we
                        * decide to modify at a later date.
                        *
                        * @enum {string}
                        * @private
                        */
  MaterialRipple.prototype.CssClasses_ = {
    RIPPLE_CENTER: 'mdl-ripple--center',
    RIPPLE_EFFECT_IGNORE_EVENTS: 'mdl-js-ripple-effect--ignore-events',
    RIPPLE: 'mdl-ripple',
    IS_ANIMATING: 'is-animating',
    IS_VISIBLE: 'is-visible' };


  /**
                                 * Handle mouse / finger down on element.
                                 *
                                 * @param {Event} event The event that fired.
                                 * @private
                                 */
  MaterialRipple.prototype.downHandler_ = function (event) {
    if (!this.rippleElement_.style.width && !this.rippleElement_.style.height) {
      var rect = this.element_.getBoundingClientRect();
      this.boundHeight = rect.height;
      this.boundWidth = rect.width;
      this.rippleSize_ = Math.sqrt(rect.width * rect.width +
      rect.height * rect.height) * 2 + 2;
      this.rippleElement_.style.width = this.rippleSize_ + 'px';
      this.rippleElement_.style.height = this.rippleSize_ + 'px';
    }

    this.rippleElement_.classList.add(this.CssClasses_.IS_VISIBLE);

    if (event.type === 'mousedown' && this.ignoringMouseDown_) {
      this.ignoringMouseDown_ = false;
    } else {
      if (event.type === 'touchstart') {
        this.ignoringMouseDown_ = true;
      }
      var frameCount = this.getFrameCount();
      if (frameCount > 0) {
        return;
      }
      this.setFrameCount(1);
      var bound = event.currentTarget.getBoundingClientRect();
      var x;
      var y;
      // Check if we are handling a keyboard click.
      if (event.clientX === 0 && event.clientY === 0) {
        x = Math.round(bound.width / 2);
        y = Math.round(bound.height / 2);
      } else {
        var clientX = event.clientX ? event.clientX : event.touches[0].clientX;
        var clientY = event.clientY ? event.clientY : event.touches[0].clientY;
        x = Math.round(clientX - bound.left);
        y = Math.round(clientY - bound.top);
      }
      this.setRippleXY(x, y);
      this.setRippleStyles(true);
      window.requestAnimationFrame(this.animFrameHandler.bind(this));
    }
  };

  /**
      * Handle mouse / finger up on element.
      *
      * @param {Event} event The event that fired.
      * @private
      */
  MaterialRipple.prototype.upHandler_ = function (event) {
    // Don't fire for the artificial "mouseup" generated by a double-click.
    if (event && event.detail !== 2) {
      // Allow a repaint to occur before removing this class, so the animation
      // shows for tap events, which seem to trigger a mouseup too soon after
      // mousedown.
      window.setTimeout(function () {
        this.rippleElement_.classList.remove(this.CssClasses_.IS_VISIBLE);
      }.bind(this), 0);
    }
  };

  /**
      * Initialize element.
      */
  MaterialRipple.prototype.init = function () {
    if (this.element_) {
      var recentering =
      this.element_.classList.contains(this.CssClasses_.RIPPLE_CENTER);
      if (!this.element_.classList.contains(
      this.CssClasses_.RIPPLE_EFFECT_IGNORE_EVENTS)) {
        this.rippleElement_ = this.element_.querySelector('.' +
        this.CssClasses_.RIPPLE);
        this.frameCount_ = 0;
        this.rippleSize_ = 0;
        this.x_ = 0;
        this.y_ = 0;

        // Touch start produces a compat mouse down event, which would cause a
        // second ripples. To avoid that, we use this property to ignore the first
        // mouse down after a touch start.
        this.ignoringMouseDown_ = false;

        this.boundDownHandler = this.downHandler_.bind(this);
        this.element_.addEventListener('mousedown',
        this.boundDownHandler);
        this.element_.addEventListener('touchstart',
        this.boundDownHandler);

        this.boundUpHandler = this.upHandler_.bind(this);
        this.element_.addEventListener('mouseup', this.boundUpHandler);
        this.element_.addEventListener('mouseleave', this.boundUpHandler);
        this.element_.addEventListener('touchend', this.boundUpHandler);
        this.element_.addEventListener('blur', this.boundUpHandler);

        /**
                                                                      * Getter for frameCount_.
                                                                      * @return {number} the frame count.
                                                                      */
        this.getFrameCount = function () {
          return this.frameCount_;
        };

        /**
            * Setter for frameCount_.
            * @param {number} fC the frame count.
            */
        this.setFrameCount = function (fC) {
          this.frameCount_ = fC;
        };

        /**
            * Getter for rippleElement_.
            * @return {Element} the ripple element.
            */
        this.getRippleElement = function () {
          return this.rippleElement_;
        };

        /**
            * Sets the ripple X and Y coordinates.
            * @param  {number} newX the new X coordinate
            * @param  {number} newY the new Y coordinate
            */
        this.setRippleXY = function (newX, newY) {
          this.x_ = newX;
          this.y_ = newY;
        };

        /**
            * Sets the ripple styles.
            * @param  {boolean} start whether or not this is the start frame.
            */
        this.setRippleStyles = function (start) {
          if (this.rippleElement_ !== null) {
            var transformString;
            var scale;
            var size;
            var offset = 'translate(' + this.x_ + 'px, ' + this.y_ + 'px)';

            if (start) {
              scale = this.Constant_.INITIAL_SCALE;
              size = this.Constant_.INITIAL_SIZE;
            } else {
              scale = this.Constant_.FINAL_SCALE;
              size = this.rippleSize_ + 'px';
              if (recentering) {
                offset = 'translate(' + this.boundWidth / 2 + 'px, ' +
                this.boundHeight / 2 + 'px)';
              }
            }

            transformString = 'translate(-50%, -50%) ' + offset + scale;

            this.rippleElement_.style.webkitTransform = transformString;
            this.rippleElement_.style.msTransform = transformString;
            this.rippleElement_.style.transform = transformString;

            if (start) {
              this.rippleElement_.classList.remove(this.CssClasses_.IS_ANIMATING);
            } else {
              this.rippleElement_.classList.add(this.CssClasses_.IS_ANIMATING);
            }
          }
        };

        /**
            * Handles an animation frame.
            */
        this.animFrameHandler = function () {
          if (this.frameCount_-- > 0) {
            window.requestAnimationFrame(this.animFrameHandler.bind(this));
          } else {
            this.setRippleStyles(false);
          }
        };
      }
    }
  };

  // The component registers itself. It can assume componentHandler is available
  // in the global scope.
  componentHandler.register({
    constructor: MaterialRipple,
    classAsString: 'MaterialRipple',
    cssClass: 'mdl-js-ripple-effect',
    widget: false });

})();
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInJpcHBsZS5qcyJdLCJuYW1lcyI6WyJNYXRlcmlhbFJpcHBsZSIsImVsZW1lbnQiLCJlbGVtZW50XyIsImluaXQiLCJ3aW5kb3ciLCJwcm90b3R5cGUiLCJDb25zdGFudF8iLCJJTklUSUFMX1NDQUxFIiwiSU5JVElBTF9TSVpFIiwiSU5JVElBTF9PUEFDSVRZIiwiRklOQUxfT1BBQ0lUWSIsIkZJTkFMX1NDQUxFIiwiQ3NzQ2xhc3Nlc18iLCJSSVBQTEVfQ0VOVEVSIiwiUklQUExFX0VGRkVDVF9JR05PUkVfRVZFTlRTIiwiUklQUExFIiwiSVNfQU5JTUFUSU5HIiwiSVNfVklTSUJMRSIsImRvd25IYW5kbGVyXyIsImV2ZW50IiwicmlwcGxlRWxlbWVudF8iLCJzdHlsZSIsIndpZHRoIiwiaGVpZ2h0IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImJvdW5kSGVpZ2h0IiwiYm91bmRXaWR0aCIsInJpcHBsZVNpemVfIiwiTWF0aCIsInNxcnQiLCJjbGFzc0xpc3QiLCJhZGQiLCJ0eXBlIiwiaWdub3JpbmdNb3VzZURvd25fIiwiZnJhbWVDb3VudCIsImdldEZyYW1lQ291bnQiLCJzZXRGcmFtZUNvdW50IiwiYm91bmQiLCJjdXJyZW50VGFyZ2V0IiwieCIsInkiLCJjbGllbnRYIiwiY2xpZW50WSIsInJvdW5kIiwidG91Y2hlcyIsImxlZnQiLCJ0b3AiLCJzZXRSaXBwbGVYWSIsInNldFJpcHBsZVN0eWxlcyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFuaW1GcmFtZUhhbmRsZXIiLCJiaW5kIiwidXBIYW5kbGVyXyIsImRldGFpbCIsInNldFRpbWVvdXQiLCJyZW1vdmUiLCJyZWNlbnRlcmluZyIsImNvbnRhaW5zIiwicXVlcnlTZWxlY3RvciIsImZyYW1lQ291bnRfIiwieF8iLCJ5XyIsImJvdW5kRG93bkhhbmRsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiYm91bmRVcEhhbmRsZXIiLCJmQyIsImdldFJpcHBsZUVsZW1lbnQiLCJuZXdYIiwibmV3WSIsInN0YXJ0IiwidHJhbnNmb3JtU3RyaW5nIiwic2NhbGUiLCJzaXplIiwib2Zmc2V0Iiwid2Via2l0VHJhbnNmb3JtIiwibXNUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJjb21wb25lbnRIYW5kbGVyIiwicmVnaXN0ZXIiLCJjb25zdHJ1Y3RvciIsImNsYXNzQXNTdHJpbmciLCJjc3NDbGFzcyIsIndpZGdldCJdLCJtYXBwaW5ncyI6ImNBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLENBQUMsWUFBVztBQUNWOztBQUVBOzs7Ozs7OztBQVFBLE1BQUlBLGlCQUFpQixTQUFTQSxjQUFULENBQXdCQyxPQUF4QixFQUFpQztBQUNwRCxTQUFLQyxRQUFMLEdBQWdCRCxPQUFoQjs7QUFFQTtBQUNBLFNBQUtFLElBQUw7QUFDRCxHQUxEO0FBTUFDLFNBQU8sZ0JBQVAsSUFBMkJKLGNBQTNCOztBQUVBOzs7Ozs7QUFNQUEsaUJBQWVLLFNBQWYsQ0FBeUJDLFNBQXpCLEdBQXFDO0FBQ25DQyxtQkFBZSx1QkFEb0I7QUFFbkNDLGtCQUFjLEtBRnFCO0FBR25DQyxxQkFBaUIsS0FIa0I7QUFJbkNDLG1CQUFlLEdBSm9CO0FBS25DQyxpQkFBYSxFQUxzQixFQUFyQzs7O0FBUUE7Ozs7Ozs7O0FBUUFYLGlCQUFlSyxTQUFmLENBQXlCTyxXQUF6QixHQUF1QztBQUNyQ0MsbUJBQWUsb0JBRHNCO0FBRXJDQyxpQ0FBNkIscUNBRlE7QUFHckNDLFlBQVEsWUFINkI7QUFJckNDLGtCQUFjLGNBSnVCO0FBS3JDQyxnQkFBWSxZQUx5QixFQUF2Qzs7O0FBUUE7Ozs7OztBQU1BakIsaUJBQWVLLFNBQWYsQ0FBeUJhLFlBQXpCLEdBQXdDLFVBQVNDLEtBQVQsRUFBZ0I7QUFDdEQsUUFBSSxDQUFDLEtBQUtDLGNBQUwsQ0FBb0JDLEtBQXBCLENBQTBCQyxLQUEzQixJQUFvQyxDQUFDLEtBQUtGLGNBQUwsQ0FBb0JDLEtBQXBCLENBQTBCRSxNQUFuRSxFQUEyRTtBQUN6RSxVQUFJQyxPQUFPLEtBQUt0QixRQUFMLENB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XG4gKiBDb3B5cmlnaHQgMjAxNSBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgLyoqXG4gICAqIENsYXNzIGNvbnN0cnVjdG9yIGZvciBSaXBwbGUgTURMIGNvbXBvbmVudC5cbiAgICogSW1wbGVtZW50cyBNREwgY29tcG9uZW50IGRlc2lnbiBwYXR0ZXJuIGRlZmluZWQgYXQ6XG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNvbm1heWVzL21kbC1jb21wb25lbnQtZGVzaWduLXBhdHRlcm5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHVwZ3JhZGVkLlxuICAgKi9cbiAgdmFyIE1hdGVyaWFsUmlwcGxlID0gZnVuY3Rpb24gTWF0ZXJpYWxSaXBwbGUoZWxlbWVudCkge1xuICAgIHRoaXMuZWxlbWVudF8gPSBlbGVtZW50O1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBpbnN0YW5jZS5cbiAgICB0aGlzLmluaXQoKTtcbiAgfTtcbiAgd2luZG93WydNYXRlcmlhbFJpcHBsZSddID0gTWF0ZXJpYWxSaXBwbGU7XG5cbiAgLyoqXG4gICAqIFN0b3JlIGNvbnN0YW50cyBpbiBvbmUgcGxhY2Ugc28gdGhleSBjYW4gYmUgdXBkYXRlZCBlYXNpbHkuXG4gICAqXG4gICAqIEBlbnVtIHtzdHJpbmcgfCBudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNYXRlcmlhbFJpcHBsZS5wcm90b3R5cGUuQ29uc3RhbnRfID0ge1xuICAgIElOSVRJQUxfU0NBTEU6ICdzY2FsZSgwLjAwMDEsIDAuMDAwMSknLFxuICAgIElOSVRJQUxfU0laRTogJzFweCcsXG4gICAgSU5JVElBTF9PUEFDSVRZOiAnMC40JyxcbiAgICBGSU5BTF9PUEFDSVRZOiAnMCcsXG4gICAgRklOQUxfU0NBTEU6ICcnXG4gIH07XG5cbiAgLyoqXG4gICAqIFN0b3JlIHN0cmluZ3MgZm9yIGNsYXNzIG5hbWVzIGRlZmluZWQgYnkgdGhpcyBjb21wb25lbnQgdGhhdCBhcmUgdXNlZCBpblxuICAgKiBKYXZhU2NyaXB0LiBUaGlzIGFsbG93cyB1cyB0byBzaW1wbHkgY2hhbmdlIGl0IGluIG9uZSBwbGFjZSBzaG91bGQgd2VcbiAgICogZGVjaWRlIHRvIG1vZGlmeSBhdCBhIGxhdGVyIGRhdGUuXG4gICAqXG4gICAqIEBlbnVtIHtzdHJpbmd9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNYXRlcmlhbFJpcHBsZS5wcm90b3R5cGUuQ3NzQ2xhc3Nlc18gPSB7XG4gICAgUklQUExFX0NFTlRFUjogJ21kbC1yaXBwbGUtLWNlbnRlcicsXG4gICAgUklQUExFX0VGRkVDVF9JR05PUkVfRVZFTlRTOiAnbWRsLWpzLXJpcHBsZS1lZmZlY3QtLWlnbm9yZS1ldmVudHMnLFxuICAgIFJJUFBMRTogJ21kbC1yaXBwbGUnLFxuICAgIElTX0FOSU1BVElORzogJ2lzLWFuaW1hdGluZycsXG4gICAgSVNfVklTSUJMRTogJ2lzLXZpc2libGUnXG4gIH07XG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSAvIGZpbmdlciBkb3duIG9uIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0aGF0IGZpcmVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgTWF0ZXJpYWxSaXBwbGUucHJvdG90eXBlLmRvd25IYW5kbGVyXyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLnJpcHBsZUVsZW1lbnRfLnN0eWxlLndpZHRoICYmICF0aGlzLnJpcHBsZUVsZW1lbnRfLnN0eWxlLmhlaWdodCkge1xuICAgICAgdmFyIHJlY3QgPSB0aGlzLmVsZW1lbnRfLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdGhpcy5ib3VuZEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xuICAgICAgdGhpcy5ib3VuZFdpZHRoID0gcmVjdC53aWR0aDtcbiAgICAgIHRoaXMucmlwcGxlU2l6ZV8gPSBNYXRoLnNxcnQocmVjdC53aWR0aCAqIHJlY3Qud2lkdGggK1xuICAgICAgICAgIHJlY3QuaGVpZ2h0ICogcmVjdC5oZWlnaHQpICogMiArIDI7XG4gICAgICB0aGlzLnJpcHBsZUVsZW1lbnRfLnN0eWxlLndpZHRoID0gdGhpcy5yaXBwbGVTaXplXyArICdweCc7XG4gICAgICB0aGlzLnJpcHBsZUVsZW1lbnRfLnN0eWxlLmhlaWdodCA9IHRoaXMucmlwcGxlU2l6ZV8gKyAncHgnO1xuICAgIH1cblxuICAgIHRoaXMucmlwcGxlRWxlbWVudF8uY2xhc3NMaXN0LmFkZCh0aGlzLkNzc0NsYXNzZXNfLklTX1ZJU0lCTEUpO1xuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZWRvd24nICYmIHRoaXMuaWdub3JpbmdNb3VzZURvd25fKSB7XG4gICAgICB0aGlzLmlnbm9yaW5nTW91c2VEb3duXyA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIHRoaXMuaWdub3JpbmdNb3VzZURvd25fID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBmcmFtZUNvdW50ID0gdGhpcy5nZXRGcmFtZUNvdW50KCk7XG4gICAgICBpZiAoZnJhbWVDb3VudCA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRGcmFtZUNvdW50KDEpO1xuICAgICAgdmFyIGJvdW5kID0gZXZlbnQuY3VycmVudFRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciB4O1xuICAgICAgdmFyIHk7XG4gICAgICAvLyBDaGVjayBpZiB3ZSBhcmUgaGFuZGxpbmcgYSBrZXlib2FyZCBjbGljay5cbiAgICAgIGlmIChldmVudC5jbGllbnRYID09PSAwICYmIGV2ZW50LmNsaWVudFkgPT09IDApIHtcbiAgICAgICAgeCA9IE1hdGgucm91bmQoYm91bmQud2lkdGggLyAyKTtcbiAgICAgICAgeSA9IE1hdGgucm91bmQoYm91bmQuaGVpZ2h0IC8gMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2xpZW50WCA9IGV2ZW50LmNsaWVudFggPyBldmVudC5jbGllbnRYIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRYO1xuICAgICAgICB2YXIgY2xpZW50WSA9IGV2ZW50LmNsaWVudFkgPyBldmVudC5jbGllbnRZIDogZXZlbnQudG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgICB4ID0gTWF0aC5yb3VuZChjbGllbnRYIC0gYm91bmQubGVmdCk7XG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKGNsaWVudFkgLSBib3VuZC50b3ApO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRSaXBwbGVYWSh4LCB5KTtcbiAgICAgIHRoaXMuc2V0UmlwcGxlU3R5bGVzKHRydWUpO1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1GcmFtZUhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgLyBmaW5nZXIgdXAgb24gZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHRoYXQgZmlyZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBNYXRlcmlhbFJpcHBsZS5wcm90b3R5cGUudXBIYW5kbGVyXyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gRG9uJ3QgZmlyZSBmb3IgdGhlIGFydGlmaWNpYWwgXCJtb3VzZXVwXCIgZ2VuZXJhdGVkIGJ5IGEgZG91YmxlLWNsaWNrLlxuICAgIGlmIChldmVudCAmJiBldmVudC5kZXRhaWwgIT09IDIpIHtcbiAgICAgIC8vIEFsbG93IGEgcmVwYWludCB0byBvY2N1ciBiZWZvcmUgcmVtb3ZpbmcgdGhpcyBjbGFzcywgc28gdGhlIGFuaW1hdGlvblxuICAgICAgLy8gc2hvd3MgZm9yIHRhcCBldmVudHMsIHdoaWNoIHNlZW0gdG8gdHJpZ2dlciBhIG1vdXNldXAgdG9vIHNvb24gYWZ0ZXJcbiAgICAgIC8vIG1vdXNlZG93bi5cbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJpcHBsZUVsZW1lbnRfLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5Dc3NDbGFzc2VzXy5JU19WSVNJQkxFKTtcbiAgICAgIH0uYmluZCh0aGlzKSwgMCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGVsZW1lbnQuXG4gICAqL1xuICBNYXRlcmlhbFJpcHBsZS5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnRfKSB7XG4gICAgICB2YXIgcmVjZW50ZXJpbmcgPVxuICAgICAgICAgIHRoaXMuZWxlbWVudF8uY2xhc3NMaXN0LmNvbnRhaW5zKHRoaXMuQ3NzQ2xhc3Nlc18uUklQUExFX0NFTlRFUik7XG4gICAgICBpZiAoIXRoaXMuZWxlbWVudF8uY2xhc3NMaXN0LmNvbnRhaW5zKFxuICAgICAgICAgIHRoaXMuQ3NzQ2xhc3Nlc18uUklQUExFX0VGRkVDVF9JR05PUkVfRVZFTlRTKSkge1xuICAgICAgICB0aGlzLnJpcHBsZUVsZW1lbnRfID0gdGhpcy5lbGVtZW50Xy5xdWVyeVNlbGVjdG9yKCcuJyArXG4gICAgICAgICAgICB0aGlzLkNzc0NsYXNzZXNfLlJJUFBMRSk7XG4gICAgICAgIHRoaXMuZnJhbWVDb3VudF8gPSAwO1xuICAgICAgICB0aGlzLnJpcHBsZVNpemVfID0gMDtcbiAgICAgICAgdGhpcy54XyA9IDA7XG4gICAgICAgIHRoaXMueV8gPSAwO1xuXG4gICAgICAgIC8vIFRvdWNoIHN0YXJ0IHByb2R1Y2VzIGEgY29tcGF0IG1vdXNlIGRvd24gZXZlbnQsIHdoaWNoIHdvdWxkIGNhdXNlIGFcbiAgICAgICAgLy8gc2Vjb25kIHJpcHBsZXMuIFRvIGF2b2lkIHRoYXQsIHdlIHVzZSB0aGlzIHByb3BlcnR5IHRvIGlnbm9yZSB0aGUgZmlyc3RcbiAgICAgICAgLy8gbW91c2UgZG93biBhZnRlciBhIHRvdWNoIHN0YXJ0LlxuICAgICAgICB0aGlzLmlnbm9yaW5nTW91c2VEb3duXyA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuYm91bmREb3duSGFuZGxlciA9IHRoaXMuZG93bkhhbmRsZXJfLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZWxlbWVudF8uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJyxcbiAgICAgICAgICB0aGlzLmJvdW5kRG93bkhhbmRsZXIpO1xuICAgICAgICB0aGlzLmVsZW1lbnRfLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLFxuICAgICAgICAgICAgdGhpcy5ib3VuZERvd25IYW5kbGVyKTtcblxuICAgICAgICB0aGlzLmJvdW5kVXBIYW5kbGVyID0gdGhpcy51cEhhbmRsZXJfLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZWxlbWVudF8uYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuYm91bmRVcEhhbmRsZXIpO1xuICAgICAgICB0aGlzLmVsZW1lbnRfLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLmJvdW5kVXBIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5lbGVtZW50Xy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuYm91bmRVcEhhbmRsZXIpO1xuICAgICAgICB0aGlzLmVsZW1lbnRfLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLmJvdW5kVXBIYW5kbGVyKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0dGVyIGZvciBmcmFtZUNvdW50Xy5cbiAgICAgICAgICogQHJldHVybiB7bnVtYmVyfSB0aGUgZnJhbWUgY291bnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEZyYW1lQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5mcmFtZUNvdW50XztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0dGVyIGZvciBmcmFtZUNvdW50Xy5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGZDIHRoZSBmcmFtZSBjb3VudC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0RnJhbWVDb3VudCA9IGZ1bmN0aW9uKGZDKSB7XG4gICAgICAgICAgdGhpcy5mcmFtZUNvdW50XyA9IGZDO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXR0ZXIgZm9yIHJpcHBsZUVsZW1lbnRfLlxuICAgICAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSB0aGUgcmlwcGxlIGVsZW1lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFJpcHBsZUVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5yaXBwbGVFbGVtZW50XztcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogU2V0cyB0aGUgcmlwcGxlIFggYW5kIFkgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqIEBwYXJhbSAge251bWJlcn0gbmV3WCB0aGUgbmV3IFggY29vcmRpbmF0ZVxuICAgICAgICAgKiBAcGFyYW0gIHtudW1iZXJ9IG5ld1kgdGhlIG5ldyBZIGNvb3JkaW5hdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2V0UmlwcGxlWFkgPSBmdW5jdGlvbihuZXdYLCBuZXdZKSB7XG4gICAgICAgICAgdGhpcy54XyA9IG5ld1g7XG4gICAgICAgICAgdGhpcy55XyA9IG5ld1k7XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNldHMgdGhlIHJpcHBsZSBzdHlsZXMuXG4gICAgICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IHN0YXJ0IHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIHN0YXJ0IGZyYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXRSaXBwbGVTdHlsZXMgPSBmdW5jdGlvbihzdGFydCkge1xuICAgICAgICAgIGlmICh0aGlzLnJpcHBsZUVsZW1lbnRfICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtU3RyaW5nO1xuICAgICAgICAgICAgdmFyIHNjYWxlO1xuICAgICAgICAgICAgdmFyIHNpemU7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gJ3RyYW5zbGF0ZSgnICsgdGhpcy54XyArICdweCwgJyArIHRoaXMueV8gKyAncHgpJztcblxuICAgICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICAgIHNjYWxlID0gdGhpcy5Db25zdGFudF8uSU5JVElBTF9TQ0FMRTtcbiAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMuQ29uc3RhbnRfLklOSVRJQUxfU0laRTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNjYWxlID0gdGhpcy5Db25zdGFudF8uRklOQUxfU0NBTEU7XG4gICAgICAgICAgICAgIHNpemUgPSB0aGlzLnJpcHBsZVNpemVfICsgJ3B4JztcbiAgICAgICAgICAgICAgaWYgKHJlY2VudGVyaW5nKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gJ3RyYW5zbGF0ZSgnICsgdGhpcy5ib3VuZFdpZHRoIC8gMiArICdweCwgJyArXG4gICAgICAgICAgICAgICAgICB0aGlzLmJvdW5kSGVpZ2h0IC8gMiArICdweCknO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRyYW5zZm9ybVN0cmluZyA9ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSkgJyArIG9mZnNldCArIHNjYWxlO1xuXG4gICAgICAgICAgICB0aGlzLnJpcHBsZUVsZW1lbnRfLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHRyYW5zZm9ybVN0cmluZztcbiAgICAgICAgICAgIHRoaXMucmlwcGxlRWxlbWVudF8uc3R5bGUubXNUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1TdHJpbmc7XG4gICAgICAgICAgICB0aGlzLnJpcHBsZUVsZW1lbnRfLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVN0cmluZztcblxuICAgICAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICAgIHRoaXMucmlwcGxlRWxlbWVudF8uY2xhc3NMaXN0LnJlbW92ZSh0aGlzLkNzc0NsYXNzZXNfLklTX0FOSU1BVElORyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnJpcHBsZUVsZW1lbnRfLmNsYXNzTGlzdC5hZGQodGhpcy5Dc3NDbGFzc2VzXy5JU19BTklNQVRJTkcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBhbiBhbmltYXRpb24gZnJhbWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFuaW1GcmFtZUhhbmRsZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAodGhpcy5mcmFtZUNvdW50Xy0tID4gMCkge1xuICAgICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLmFuaW1GcmFtZUhhbmRsZXIuYmluZCh0aGlzKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0UmlwcGxlU3R5bGVzKGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIFRoZSBjb21wb25lbnQgcmVnaXN0ZXJzIGl0c2VsZi4gSXQgY2FuIGFzc3VtZSBjb21wb25lbnRIYW5kbGVyIGlzIGF2YWlsYWJsZVxuICAvLyBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxuICBjb21wb25lbnRIYW5kbGVyLnJlZ2lzdGVyKHtcbiAgICBjb25zdHJ1Y3RvcjogTWF0ZXJpYWxSaXBwbGUsXG4gICAgY2xhc3NBc1N0cmluZzogJ01hdGVyaWFsUmlwcGxlJyxcbiAgICBjc3NDbGFzczogJ21kbC1qcy1yaXBwbGUtZWZmZWN0JyxcbiAgICB3aWRnZXQ6IGZhbHNlXG4gIH0pO1xufSkoKTtcbiJdfQ==
